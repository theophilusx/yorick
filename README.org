* Yorick

/Yorick/ is a library of reagent components which use the [[https://bulma.io][Bulma]] framework for
CSS styling. Bulma is a full featured pure CSS framework which does not include
any Javascript. This library builds on this and adds necessary Javascript to
create high level Reagent components to represent functionality commonly
required when developing web based applications. 

Yorick has been developed using the excellent [[https://github.com/thheller/shadow-cljs][shadow-cljs]] library, but can be
used with any ClojureScript build environment, such as /lein/, /CLI tools/ or
/boot/.

** Key Objectives

   - High level API. Make it easy to do the easy stuff
   - Flexible. Make it possible to do the hard stuff
   - Interchangeable. Easily combine components and compose components to create new components
   - Consistent and intuitive. Once you get use to the library, be able to make reasonable guesses regarding available arguments and options
   - Data driven. Whenever possible, allow definition of components to be done
     in basic data structures like /maps/ and /vectors/.
 
** Installation 

   Until we add this library to clojars (in the near future), you will need to
   clone this repository into your project. All the necessary code is in the
   ~src~ tree. There is also a simple /demo/ application in the ~demo~ tree
   which shows how to use some of the components and what they look like when
   rendered. To run the demo, do the following

#+begin_example
git clone https://github.com/theophilusx/yorick .
cd yorick
npm install
npx shadow-cljs server build demo
#+end_example

Then visit [[http://localhost:8080][demo page]] 

** Using the API

   The library makes extensive use of keyword arguments. This has the advantage
   of making simple default function calls very clean and easy to do, but
   provides an /escape hatch/ when you need to do more complicated things. The
   disadvantage is that ifyou need to do lots of complicated things, the
   function calls can become very long. However, if you do need to do such
   complicated things a lot, it is probably a sign you need to create higher
   level abstractions to restrict the complexity to well defined points.

   Many HTML entities have large numbers of attributes that can be used with
   them. However, most of the time, only a few of these are necessary. This
   library tries to add sensible defaults for many of these attributes and
   allows you to add them when necessary via /keyword/ arguments. There are also
   some /tricks/ you can use to get around some common issues that come up when
   working with components.

*** Working with classes

    The standard way to modify the appearance of a component is by adding CSS
    classes. As /bulma/ is a pure CSS framework, all Bulma features are
    controlled by adding Bulma specific class names to elements. See the Bulma
    documentation for details on what class names are supported for each
    element. 

    Many components are actually made up of multiple HTML
    elements and applying specific classes to each of these elements can become
    untidy and difficult to maintain. To handle this level of complexity, this
    library uses the following conventions

    1. When these is just a single element in the component, allow a keyword
       argument of ~:class~. This argument can have either a string value where
       the string lists the CSS classes to be added to the element or a vector,
       which contains values that will resolve to a string (or nil).

    2. When the component is a composition of HTML elements, a ~:classes~
       argument is supported. The value of this argument should be a ~map~ where
       the keys are keywords representing HTML elements and the value associated
       with the key is either a string containing CSS class names or a vector
       which contains values that will resolve to CSS class name strings or nil.

**** Examples

    The `a` component is a basic component that renders an HTML link element. As it only has one element, the ~:class~ keyword argument is supported. For example

    #+begin_src clojurescript
      [:p "This is a paragraph with a link of " [a "link name" :class "button"]
       ". It is a button link"]
    #+end_src

    This will generate HTML which looks like

    #+begin_src html
      <p>This is a paragraph with a link of 
      <a href="#" class="button">link name</a>. It is a button link
      </p>
    #+end_src

    Alternatively, you could use a vector for the value of ~:class~. This can be
    very useful when you want to add something dynamic i.e. which calculates the
    value of the class name to add. For example

    #+begin_src clojurescript
      [:p "This is a link with a dynamic class name "
       [a "link name" :class ["button"
                              (when (= (:link-state @state) :active)
                                "is-active")]
        ". It is an active button link"]]
    #+end_src

    The above uses a ~when~ conditional to add the /is-active/ class if the
    value of the key ~:link-state~ is ~:active~. If it is not ~:active~, it will
    add ~nil~, which will be ignored. So if the value is ~:active~ the result
    will be

    #+begin_src html
      <p>
        This is a link with a dynamic class name  
        <a href="#" class="button is-active">link name</a>
        . It is an active button link
      </p>
    #+end_src

    The ~input-field~ component is an example of a component which is made up of
    multiple HTML elements. There is an outer ~:div~ element for the field, a
    ~:label~ element for the field label, a ~:control~ field to contain the
    final ~:input~ element. Therefore, the ~input-field~ element supports the
    ~:classes~ keyword argument, which should have a ~map~ as the value. This
    map should have keys for one or more of the inner elements i.e. ~:field~,
    ~:label~, ~:control~ or ~:input~. You only need to add keys for the elements
    you want to add classes to. The value of each key can be either a string of
    class names or a vector with components that will resolve to a class name
    string or nil. 
    
*** Component contents 

    In most cases, a component is really just a wrapper around other components
    or HTML elements. An element can be as simple as just a string or as complex
    as a nested HTML table. In most cases, the components provided by /Yorick/
    only accept a single value for the /body/ argument of the component.
    However, sometimes you might want to provide multiple values. To enable
    passing multiple values into a component, it is necessary to wrap it in
    either an explicit ~:div~ element or you can use the handy ~:<>~ shortcut.
    This is also a requirement of ~React~ - the value passed into a ~React~
    component must be either a vector or a function which returns a vector. You
    cannot just pass in a nested vector, so something like 

    #+begin_src clojurescript
      [field [[button "Save"]
              [Button "Cancel"]]]
    #+end_src

    won't work. It will generate an error about invalid hiccup. However the
    following two approaches will work just fine. 

    #+begin_src clojurescript
      [field [:div
              [button "Save"]
              [button "Cancel"]]]

      [field [:<>
              [button "Save"]
              [button "Cancel"]]]
    #+end_src

    The first will wrap the two button components in a ~<div>~, which is usually
    fine. The second will enable ~React~ to handle the two button components and
    may avoid the addition of an explicit ~<div>~ element. 

*** API Namespaces

    The API uses separate namespaces for most components. The ~core~ namespace
    is a wrapper around most of the component namespaces. If your going to use
    most of the components provided by /Yorick/, your best off just loading the
    core namespace. However, If you only want to use specific components, you
    can just load the associated namespace for that component. The following
    namespaces are used -

    | Namespace                   | Purpose                                  |
    |-----------------------------+------------------------------------------|
    | theophilusx.yorick.basic    | Very simple and basic components         |
    | theophilusx.yorick.card     | A ~card~ component                       |
    | theophilusx.yorick.icon     | A simple icon component                  |
    | theophilusx.yorick.input    | A collection of input related components |
    | theophilusx.yorick.media    | A flexible media component               |
    | theophilusx.yorick.modal    | A modal window component                 |
    | theophilusx.yorick.navbar   | A navigation bar component               |
    | theophilusx.yorick.paginate | A pagination component                   |
    | theophilusx.yorick.sidebar  | A sidebar menu component                 |
    | theophilusx.yorick.table    | An HTML table component                  |
    | theophilusx.yorick.toolbar  | A simple toolbar component               |
